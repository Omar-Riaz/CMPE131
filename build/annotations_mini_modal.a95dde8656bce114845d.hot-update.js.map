{"version":3,"file":"annotations_mini_modal.a95dde8656bce114845d.hot-update.js","sources":["webpack:///./src/annotations_list.js"],"sourcesContent":["const React = require('react');\r\nconst ReactDOM = require('react-dom');\r\nconst annotationFunctionsClass = require('./annotationFunctions').default;\r\nconst annotationModal = require('./annotations_modal.js');\r\nimport AnnotationMap from './data_structs/annotationMap';\r\nimport Autosuggest from 'react-autosuggest';\r\n\r\nAnnotationMap();\r\n\r\nfunction isEmptyObject(obj){\r\n  return obj == null || (Object.keys(obj).length === 0 && obj.constructor === Object)\r\n}\r\n\r\n//step 1: load the whole function --> goes through instantiation\r\n//step 2: use the instants to deal with the information\r\nexport default function (urlArg) {\r\n\t\r\nvar url = urlArg; \r\n\t\r\nif (!String.prototype.trim) {\r\n\r\n\tString.prototype.trim = function () {\r\n\t\treturn this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\r\n\t};\r\n}\r\n\r\n\r\nclass ChannelSearchBar extends React.Component {\r\n  constructor() {\r\n    super();\r\n\r\n    // Autosuggest is a controlled component.\r\n    // This means that you need to provide an input value\r\n    // and an onChange handler that updates this value (see below).\r\n    // Suggestions also need to be provided to the Autosuggest,\r\n    // and they are initially empty because the Autosuggest is closed.\r\n\t\r\n\t//NEEDED STATE VARIABLES: value --> newAnnotationText, suggestions --> channels(unselected)  \r\n\t//dummy string needed to avoid bug\r\n    this.state = {\r\n\t\tvalue: '',\r\n\t\tsuggestions: []\r\n\t};\r\n\tthis.getSuggestions = this.getSuggestions.bind(this);\r\n\tthis.getSuggestionValue = this.getSuggestionValue.bind(this);\r\n\tthis.renderSuggestion = this.renderSuggestion.bind(this);\r\n\tthis.onChange = this.onChange.bind(this);\r\n\tthis.updateState = this.updateState.bind(this);\r\n\r\n  }\r\n\r\n\t\r\n\t// Teach Autosuggest how to calculate suggestions for any given input value.\r\n\tgetSuggestions = (value)=>{\r\n\t\tconst inputValue = value == undefined ? '' : value.trim().toLowerCase();\r\n\t\tconst inputLength = inputValue.length;\r\n\t\t\r\n\r\n\t\treturn inputLength === 0 ? [] : this.props.suggestions.filter(channel=>\r\n\t\t\tchannel.toLowerCase().slice(0, inputLength) === inputValue\r\n\t\t);\r\n\t};\r\n\t\r\n\t// Use your imagination to render suggestions.\r\n\trenderSuggestion(suggestion){\r\n\t\treturn(\r\n\t\t\t<div className=\"list-group-item\">\r\n\t\t\t\t{suggestion}\r\n\t\t\t</div>\r\n\t\t);\r\n\t}\r\n\t\r\n\t\r\n\t// When suggestion is clicked, Autosuggest needs to populate the input\r\n\t// based on the clicked suggestion. Teach Autosuggest how to calculate the\r\n\t// input value for every given suggestion.\r\n\tgetSuggestionValue(suggestion){return suggestion;}\r\n\t\r\n\r\n\tonChange(event, obj){\r\n\t\tthis.updateState({\r\n\t\t\tvalue: obj.newValue\r\n\t\t});\r\n\t\tthis.props.onChange(event);\t\t\t\t\t//call any onChange event that was passed as a prop.\r\n\t};\r\n\r\n\t\r\n\tonSuggestionsFetchRequested = ({value}) =>{\r\n\t\tthis.setState({\r\n\t\t\tsuggestions: this.getSuggestions(value)\r\n\t\t});\r\n\t};\r\n\r\n\t// Autosuggest will call this function every time you need to clear suggestions.\r\n\tonSuggestionsClearRequested = ()=>{\r\n\t\tthis.setState({\r\n\t\t\tsuggestions: []\r\n\t\t});\r\n  \t};\r\n\r\n  \t//call updateState from the parent to update the ChannelSearchBar\r\n  \tupdateState(newState){\r\n  \t  \t//change parent State\t\r\n  \t  \tlet oldState = Object.create(this.state);\t\t//create new object to prevent overwritting the old state\r\n  \t  \tObject.assign(oldState, newState);\t\t\t\t//assign only what we want to change.\r\n  \t  \tthis.setState(oldState);\r\n  \t  }\r\n\r\n\r\n  \trender() {\r\n\t\t//this.getSuggestions(this.props.suggestions);\r\n\t\tconst { value, suggestions } = this.state;\r\n\t\t  // Autosuggest will pass through all these props to the input.\r\n  \t\t  const inputProps = {\r\n  \t\t    placeholder: 'Type a channel', \r\n  \t\t    value,\r\n  \t\t    onChange: this.onChange,\r\n\t\t\t\t\tonClick: evt=>{evt.target.select();}\r\n  \t\t  };\r\n\t\t\t\r\n\t\t//onClick={evt=>{evt.target.select();}}>\r\n  \t\t  // Finally, render it!\r\n  \t\t  return (\r\n  \t\t    <Autosuggest\r\n  \t\t      suggestions={suggestions}\r\n  \t\t      onSuggestionsFetchRequested={this.onSuggestionsFetchRequested}\r\n  \t\t      onSuggestionsClearRequested={this.onSuggestionsClearRequested}\r\n\t\t\t  \t\talwaysRenderSuggestions={true}\r\n  \t\t      getSuggestionValue={this.getSuggestionValue}\r\n  \t\t      renderSuggestion={this.renderSuggestion}\r\n  \t\t      inputProps={inputProps}\r\n  \t\t    />\r\n  \t\t  );\r\n  \t}\r\n}\r\n\r\n\r\n\tconst annotationFunctions = annotationFunctionsClass();\r\n\r\n\tconst QuoteText = function(){\r\n\t\treturn(<div ref={quote=>{this.quote=quote}} className=\"quotes\">{document.getSelection().toString()}</div>);\r\n\t};\r\n\t//The annotation environment holds the mode that the application is in: normal or compact\r\n\t//Based on the mode, it then arranges the \r\n\tclass AnnotationEnvironment extends React.Component{\r\n\t\tconstructor(props){\r\n\t\t\tsuper();\r\n\t\t\t//state contains current information\r\n\t\t\t//selected contains information of the selected quote(s) before the operation occured\r\n\t\t\t//selectedChannels contains all the channels that are currently asociasted with the annotation you are making/editing\r\n\t\t\t//newAnnotationChannels is a string that holds the value of the field for specifying channels to select\r\n\t\t\t//an entry from newAnnoationChannels is transferred over to selectedChannels upon approval of a new channel name/of an already exisitng channel\r\n\t\t\tthis.state = {\r\n\t\t\t\tmode: \"\",\r\n\t\t\t\tannotationObjects: new annotationMap(),\r\n\t\t\t\tselectedChannels : [\"default\"],\r\n\t\t\t\tquote: \"\"\r\n\t\t\t};\r\n\t\t\t// this.quote = \"\";\r\n\t\t\t// this.newAnnotationText = \"\";\r\n\t\t\tthis.newAnnotationChannels = [];\r\n\t\t\tthis.url = url;\r\n\t\t\tthis.prevOperation = \"\";\r\n\t\t\tthis.operation = \"\";\r\n\t\t\tthis.submitAnnotationEdit = this.submitAnnotationEdit.bind(this);\r\n\t\t\tthis.newAnnotation = this.newAnnotation.bind(this);\t\r\n\t\t\tthis.deleteAnnotation = this.deleteAnnotation.bind(this);\r\n\t\t\tthis.editAnnotation = this.editAnnotation.bind(this);\r\n\t\t\tthis.updateState = this.updateState.bind(this);\r\n\t\t\tthis.switchAnnotationStyle = this.switchAnnotationStyle.bind(this);\r\n\t\t\tthis.submitType = this.submitType.bind(this);\r\n\r\n\t\t}\r\n\t\t//wrapper for this.setState, which also updates the front-end in some ways such as passing down selection changes \r\n\t\tupdateState(newState){\r\n\t\t\t//change parent State\t\r\n\t\t\tlet oldState = Object.create(this.state);\t\t//create new object to prevent overwritting the old state\r\n\t\t\tObject.assign(oldState, newState);\t\t\t\t//assign only what we want to change.\r\n\t\t\tthis.setState(oldState);\r\n\t\t\t//change child State indirectly, by passing down\r\n\t\t\t\t//if(this.state.selected)this.state.selected.undoSelection();\t\t\t\r\n\t\t\t\t//if(this.selected)\tthis.selected = null;\r\n\t\t}\r\n\t\t\r\n\t\tswitchAnnotationStyle(){\r\n\t\t\tif(this.selected.refs[this.selected.props.quote].style.background == \"#c4c4c4\")\tthis.selected.refs[this.selected.props.quote].style.background = \"#FFFFFF\";\r\n\t\t\telse\tthis.selected.refs[this.selected.props.quote].style.background = \"#c4c4c4\";\r\n\t\t}\r\n\r\n\t\tcomponentDidMount(){\r\n\t\t\tlet annotationObjects = new annotationMap();\r\n\t\t\t//get all the annotations\r\n      //STORAGE: aQuote: {obj containing annotation, channels, etc.}\r\n      // chrome.storage.sync.clear();\r\n      chrome.storage.sync.get(null, (storage) => {\r\n\t\t\t  if(!isEmptyObject(storage)){\r\n          Object.entries(storage).map(storageItem => {\r\n          \tconsole.log(storageItem);\r\n            // storageItem.channels.map(channel => {\r\n            //   annotationObjects.add(channel, storageItem);\r\n            // });\r\n            // storageItem[1].channels.map(channel =>{\t\t\t\t\t\t\t//[1] to access the values of the [key,val] array element\r\n            //   annotationObjects.add(channel, storageItem[1])\r\n            // })\r\n\t\t\t\t\t\tannotationObjects.add(storageItem[1].channels, storageItem[1]);         \t\t//[1] to access the values of the [key,val] array element\r\n          });\r\n        }\r\n        this.updateState({annotationObjects: annotationObjects});\r\n\t\t\t  this.operation = \"new\";\r\n      });\r\n      // annotationObjects.add([\"Family\", \"Friends\"], {quote: \"list\", annotation: \"cool3\", channels: [\"Family\", \"Friends\"]});\r\n\r\n\r\n      // this.updateState({annotationObjects: annotationObjects, operation: \"new\"});\r\n\t\t\t//the environment registers an event for selecting text\r\n\t\t\tdocument.addEventListener('mouseup', event=>{\r\n\t\t\t\tlet selection = document.getSelection().toString().trim();\r\n\t\t\t\tif(selection !== this.state.quote && selection !== \"\"){\r\n\t\t\t\t\tthis.updateState({quote: selection});\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t//optimizations and error fixes with regards to updating and rendering\r\n\t\t//PREVENTS BOTH RENDER AND BACKEND CHANGES FROM BEING MADE!!!\r\n\t\tshouldComponentUpdate(nextProps, nextState){\r\n\t\t\treturn true;\r\n\t\t}\t\r\n\t\t//whenever the state changes, we reflect the change in the backend (for now, the chrome API)\r\n\t\tcomponentDidUpdate(){\r\n\t\t\tlet key = {};\r\n\t\t\tif(this.operation === \"\" || this.selected == null) return;\t\t//we need a defined operation to proceed, and an annotation to perform said operation on\r\n\t\t\tlet url = this.url;\r\n\t\t\tlet annotation = this.selected.props.annotation;\r\n\t\t\tlet quote = this.selected.props.quote;\r\n\t\t\tlet channels = this.selected.props.channels;\r\n\t\t\tif(this.operation === \"delete\"){\r\n\t\t\t\tchrome.storage.sync.remove(quote);\r\n\t\t\t}else if(this.operation === \"edit\" || this.operation === \"new\"){\r\n\t\t\t\tannotationFunctions.save(quote, annotation, channels);\t\t//save the annotation in storage API with specified properties\r\n\t\t\t}\r\n\t\t\tthis.operation = this.prevOperation;\r\n\t\t}\r\n\r\n\t\t//delete an annnotation, and return the deleted annotation\r\n\t\tdeleteAnnotation(element){\r\n      let newAnnotationMap = new annotationMap(this.state.annotationObjects).deleteAnnotation(this.selected.props.channels, this.selected.props.quote);;\r\n\t\t\t// this.updateState({\r\n\t\t\t// \toperation: \"delete\",\r\n\t\t\t// \tannotationObjects:\r\n      // \t\t\t// });\r\n\t\t\tthis.prevOperation = this.operation;\r\n      this.operation = \"delete\";\r\n\t\t\tthis.setState({\r\n        annotationObjects: newAnnotationMap\r\n      });\r\n\t\t}\r\n\r\n\t\t//the annotationList's only responsibility is to select the quote to edit. remaining parts of task are deffered to the modal\r\n\t\teditAnnotation(element){\r\n      //clear prior newAnnotationText HTML <input> field\r\n      this.annotation.innerHTML = \"\";\r\n      this.prevOperation = this.operation;\r\n      this.operation = \"pre-edit\";\r\n\t\t\tthis.switchAnnotationStyle();\r\n\t\t}\r\n\r\n\t\t//in future, props can be created by invoking AnnotationList method for converting annotation to rendered annotation?.\r\n\t\tnewAnnotation(){\r\n\t\t  let newAnnotation = {\r\n\t\t  \tquote: this.state.quote,\r\n\t\t\t\tannotation: this.annotation.value,\r\n\t\t\t\tchannels: this.newAnnotationChannels\r\n\t\t\t};\r\n\t\t\tlet newAnnotationMap = new annotationMap(this.state.annotationObjects).add(newAnnotation.channels, newAnnotation);\r\n      this.selected = {\r\n      \tprops: newAnnotation\r\n\t\t\t};\r\n\t\t\tconsole.log(\"newAnnotationMap: \" + newAnnotationMap);\r\n      this.setState({\r\n        annotationObjects: newAnnotationMap\r\n      });\r\n      this.newAnnotationChannels = newAnnotationMap.keysAsArray();\r\n      this.prevOperation = this.operation;\r\n      this.operation = \"new\";\r\n      console.log(\"new annotation added\");\r\n\t\t}\r\n\r\n\t\t//submit an annotation edit\r\n\t\tsubmitAnnotationEdit(){\r\n\t\t\t// let index = this.selected.props.index;\r\n\t\t\t// let theChannels = this.state.annotationObjects[this.selected.props.channel];\r\n\t\t\t// //update the annotation that is selected, by creating a new collection of annotations and modifying it\r\n\t\t\t// //this.state.annotationObjects[index].annotation = this.newAnnotationText\r\n\t\t\t//;\r\n\t\t\t// let newAnnotationObjects = Object.create(theChannel);\r\n\t\t\t// newAnnotationObjects[index].annotation = this.newAnnotationText\r\n\t\t\t//;\r\n\t\t\tlet newAnnotationMap = new annotationMap(this.state.annotationObjects).editAnnotation(this.selected.props.channels, this.selected.props.quote, this.annotation.value);\r\n\t\t\tthis.updateState({\r\n\t\t\t\tannotationObjects: newAnnotationMap,\r\n      });\r\n\t\t\tthis.newAnnotationChannels = newAnnotationMap.keysAsArray();\r\n\t\t\tthis.prevOperation = this.operation;\r\n\t\t\tthis.operation = \"edit\";\r\n\t\t\tthis.switchAnnotationStyle();\r\n\t\t}\r\n\t\t\r\n\t\tsubmitType(action){\r\n\t\t\t//operations that happen when submitting an annotation --> happens for making new Annotations and editing annotations\r\n\t\t\tif(this.state.quote === \"\" || this.annotation.value === \"\")  return;\r\n\r\n\t\t\tif(action == \"new\"){\r\n\t\t\t\t\tthis.newAnnotation();\r\n\t\t\t  }else if(action == \"pre-edit\"){\r\n\t\t\t\t\tthis.submitAnnotationEdit();\r\n\t\t\t  }\r\n\t\t};\r\n\r\n\r\n\t\t//utility functions used in render()\r\n\r\n    \tkeyPress = evt=>{\r\n    \t\tif(evt.key == \"Enter\") this.submitType(this.operation);\r\n    \t};\r\n\r\n    \tsearchBarChange = evt=>{\r\n    \t\tlet val:String = evt.target.value;\r\n    \t\tthis.newAnnotationChannels = val.split(/,\\s*/).filter(elem=>elem.length > 0);\r\n    \t};\r\n\r\n  render() {\r\n\r\n  \tconst floatStyle={\r\n\t\t\t\tfloat: \"right\"\r\n\t\t\t};\r\n\r\n  \tconsole.log(this.state.annotationObjects);\r\n  \tconsole.log(this.state.quote);\r\n\r\n\t\t\treturn(\r\n\t\t\t\t<div className=\"annotationEnvironment\">\r\n\t\t\t\t\t<div className=\"quotes\">{this.state.quote}</div>\r\n\t\t\t\t\t<div>Annotation Channels: </div>\r\n\t\t\t\t\t<ChannelSearchBar suggestions={this.state.annotationObjects.keysAsArray()} onKeyPress={this.keyPress} onChange={this.searchBarChange}></ChannelSearchBar>\r\n\t\t\t\t\t<div>Your Annotation: </div><input ref={annotation=>{this.annotation=annotation}} className=\"annotation\" onKeyPress={this.keyPress} onClick={evt=>{evt.target.select();}} type=\"text\"></input>\r\n\t\t\t\t\t<AnnotationList deleteAnnotation={element=>{this.selected=element; this.deleteAnnotation(element);}} url={this.url} annotationObjects={this.state.annotationObjects} editAnnotation={element=>{this.selected=element; this.editAnnotation(element);}} key=\"annotationList\"/>\r\n\t\t\t\t</div>\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\r\n    class AnnotationList extends React.Component {\r\n\r\n        constructor(props) {\r\n            super();\r\n\t\t    }\r\n\r\n        render() {               //rendering a single annotationObject for each element in annotationObjects\r\n          let annotationsToRender = [];\r\n          if(!isEmptyObject(this.props.annotationObjects) && this.props.annotationObjects.size > 0){\r\n          \tlet keys = new Set();\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//for rendering only one annotation if there are multiple channels specified\r\n            this.props.annotationObjects.forEach((value, channel) => {\r\n              value.map(annotation=>{\r\n                if(!keys.has(annotation.quote)){\r\n                  annotationsToRender.push(<AnnotationElement editAnnotation={element=>{this.props.editAnnotation(element)}} deleteAnnotation={element=>{this.props.deleteAnnotation(element)}} key={annotation.quote} quote={annotation.quote} annotation={annotation.annotation} channels={annotation.channels}/>);\r\n\t\t\t\t\t\t\t\t\tkeys.add(annotation.quote);\r\n                }\r\n              });\r\n            });\r\n          }\r\n\r\n\r\n          return (\r\n            <div>\r\n              {annotationsToRender}\r\n            </div>\r\n          );\r\n        }\r\n    }\r\n\r\n\r\n    class AnnotationElement extends React.Component {\r\n\r\n\t  constructor() {\r\n\t\t\tsuper();\r\n\t\t\tthis.editAnnotation = this.editAnnotation.bind(this);\r\n\t\t\tthis.deleteAnnotation = this.deleteAnnotation.bind(this);\r\n\t  };\r\n\t\t\t/*shouldComponentUpdate(){\r\n\t\t\t\tif(this.state.selected == true)\treturn true;\r\n\t\t\t\telse return false;\r\n\t\t}*/\r\n\t\t//ref callbacks to assign the selected instance variable in parent. In future, need to make the ref in the div a callback\r\n\t\teditAnnotation(){\r\n\t\t\tthis.props.editAnnotation(this);\r\n\t\t};\r\n\t\tdeleteAnnotation(){\r\n\t\t\tthis.props.deleteAnnotation(this);\r\n\t\t};\r\n\r\n\t\trender() {\r\n            return (\r\n\t\t\t\t\t<div className=\"container\" style={this.props.elementStyling} ref={this.props.quote}>\r\n   \t\t\t\t\t\t<div className=\"quotes\">\"{this.props.quote}\"</div>\r\n\t\t\t\t\t\t<div className=\"annotations\">&emsp;{this.props.annotation}</div>\r\n            <button type=\"button\" className=\"btn btn-default\" onClick={this.deleteAnnotation}>\r\n              <span className=\"glyphicon glyphicon-trash\"></span> Delete\r\n            </button>&emsp;\r\n            <button type=\"button\" className=\"btn btn-default\" onClick={this.editAnnotation}>\r\n              <span className=\"glyphicon glyphicon-pencil\"></span> Edit\r\n            </button>\r\n            <div className=\"channels\">#{this.props.channels.map(channel => <span className=\"channel\">{channel}</span>)}</div>\r\n\t\t\t\t\t</div>\r\n            );\r\n        }\r\n    }\r\n\t\r\n    ReactDOM.render(\r\n\t\t<AnnotationEnvironment/>,\r\n        document.getElementsByClassName('annotationList')[0]\r\n    );\r\n\r\n};"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AADA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAVA;AAAA;AAAA;AAAA;AACA;AAYA;AAAA;AACA;AADA;AACA;AAAA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAXA;AA0BA;AACA;AAGA;AAAA;AAAA;AAGA;AACA;AAlCA;AA2DA;AACA;AAAA;AACA;AADA;AAGA;AACA;AAhEA;AAmEA;AACA;AADA;AAGA;AACA;AA5DA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AAnBA;AAqBA;AACA;AACA;AApCA;AAAA;AAgDA;AAhDA;AAkDA;AACA;AAAA;AAIA;AAIA;AACA;AACA;AA7DA;AAAA;AAAA;AA6DA;AAAA;AA7DA;AAAA;AAAA;AAiEA;AACA;AADA;AAGA;AACA;AArEA;AAAA;AAqFA;AArFA;AAuFA;AACA;AACA;AAAA;AACA;AAAA;AACA;AA3FA;AAAA;AAAA;AA+FA;AADA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAJA;AAQA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAUA;AAtHA;AACA;AADA;AAAA;AACA;AAyHA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAlIA;AAAA;AAAA;AAAA;AACA;AAiIA;AAAA;AACA;AADA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAPA;AAkLA;AACA;AACA;AApLA;AAsLA;AACA;AAAA;AAAA;AACA;AACA;AAlLA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzBA;AA2BA;AACA;AACA;AA/JA;AAAA;AAAA;AAgKA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAvKA;AAAA;AAAA;AA0KA;AAEA;AA5KA;AAAA;AAAA;AA8KA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAGA;AACA;AAlNA;AAAA;AAAA;AAmNA;AACA;AACA;AArNA;AAAA;AAAA;AAuNA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AApOA;AAAA;AAAA;AAuOA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AADA;AAGA;AACA;AAlPA;AAAA;AAAA;AAqPA;AACA;AACA;AACA;AACA;AACA;AACA;AA3PA;AAAA;AAAA;AA8PA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AADA;AAGA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AAhRA;AAAA;AAAA;AAmRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AAnSA;AAAA;AAAA;AAsSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9SA;AAAA;AAAA;AA4TA;AACA;AACA;AACA;AADA;AAIA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAGA;AA9UA;AACA;AADA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AAmVA;AAAA;AACA;AADA;AAEA;AACA;AAvVA;AAAA;AAAA;AAwVA;AACA;AADA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AA5WA;AACA;AADA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AAiXA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AAHA;AAIA;AACA;AAvXA;AAAA;AACA;AAsXA;;;;AAIA;AA3XA;AA6XA;AACA;AA9XA;AAAA;AAAA;AAgYA;AACA;AAjYA;AAAA;AAAA;AAoYA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAjZA;AACA;AADA;AAAA;AACA;AAmZA;AAKA;AAAA;;;;A","sourceRoot":""}